---
title: "Confounder & Randomization Challenge"
subtitle: "Recovering Lost Figures: Visualizing Confounders and Causal Inference"
format:
  html: default
bibliography: references.bib
execute:
  echo: true
  eval: true
---

:::: {.callout-important}
## üìã The Challenge: Recover the Lost Figures!

A critical report on confounding and causal inference was being prepared when disaster struck‚Äîthe figures were lost! The data files survived (`patients_data.csv` and `patients_data_randomized.csv`), and the narrative text is intact, but **all three key visualizations have disappeared**.

Your mission: **Recover the lost figures** by reading the narrative carefully and creating compelling visualizations that match the story being told. The figures must be:

- **Figure 1**: Post-surgical outcomes by patient (observational data)
- **Figure 2**: Post-surgical outcomes for randomized patients  
- **Figure 3**: Post-surgical outcomes by patient severity (stratification)

Use the text descriptions, statistical results, and your understanding of visualization best practices to recreate these figures. Your figures should be professional, colorblind-friendly, and tell the story clearly.

**Grading:** Completing the three figures correctly will earn you 85% of the grade. To earn the final 15% (for a total of 100%), you must make it feel like a complete, professional report rather than a challenge assignment
::::

:::: {.callout-warning}
## ‚ö†Ô∏è AI Partnership Required
Use Cursor AI for speed, but ensure you understand and can explain your visualizations in your own words. The goal is to create figures that match the narrative and statistical insights described in the text.
::::

## The Paradox: Who *Really* Is the Better Surgeon?

::: {.callout-tip title="A Tale of Two Surgeons" icon=false}
*Paraphrased from* [@taleb2017surgeons]

<div style="float: right; margin-left: 15px; margin-bottom: 10px;">
<img src="docSideBySide.jpg" alt="Doc Dreamy and Doc Duck side by side" style="max-width: 250px; height: auto; border-radius: 5px;">
</div>

Imagine you need to choose between two surgeons of similar rank at the same hospital. The first surgeon, Doc Dreamy, matches our stereotype perfectly: refined appearance, silver-rimmed glasses, delicate hands, measured speech, and an office adorned with Ivy League diplomas (see the image). The second surgeon, Doc Duck, by contrast, looks more like a butcher‚Äîoverweight, with large hands, an unkempt appearance, and no visible credentials on the wall.

Counterintuitively, the surgeon who doesn't "look the part" may actually be the better choice. Why? Because when someone succeeds in their profession despite not fitting the expected appearance, it suggests they had to overcome significant perceptual biases. And if we are lucky enough to have people who do not look the part, it is thanks to the presence of some skin in the game, the contact with reality that filters out incompetence. [@taleb2017surgeons]
:::

## Observational Data: A Misleading Victory for Doc Dreamy

```{python}
#| label: simulate-data
#| echo: false
#| message: false
#| warning: false
#| include: false

import pandas as pd
import numpy as np

# Set seed for reproducibility
np.random.seed(123)

# Create dataframe with 100 patients and severity scores
n_patients = 100
patients_df = (
    pd.DataFrame({
        'patient': range(1, n_patients + 1),
        'severity': np.random.normal(0, 1, n_patients)
    })
    .assign(
        # Assign doctors based on severity using sigmoid function:
        # Probability of Doc Duck is inversely proportional to severity
        # Higher severity ‚Üí higher probability of Doc Duck
        # Uses sigmoid: P(Doc Duck) = 1 / (1 + exp(-k * severity))
        # where k controls the steepness of the relationship
        prob_duck=lambda df: 1 / (1 + np.exp(-1.5 * df['severity'])),  # k=1.5 controls sensitivity
        # Random assignment: if random < prob_duck ‚Üí Doc Duck (id=0), else Doc Dreamy (id=1)
        doctor_id=lambda df: (np.random.random(n_patients) >= df['prob_duck']).astype(int),
        # Assign doctor names based on id
        doctor_name=lambda df: np.where(df['doctor_id'] == 1, 'Doc Dreamy', 'Doc Duck'),
        # Assign surgical goodness:
        # Doc Duck: Normal(0.2, 1), Doc Dreamy: Normal(-0.2, 1)
        surgicalGoodness=lambda df: np.where(
            df['doctor_name'] == 'Doc Duck',
            np.random.normal(0.5, 1, n_patients),
            np.random.normal(-0.4, 1, n_patients)
        ),
        # Calculate post-surgical severity: initial severity - surgical goodness + 3
        post_surgical_score=lambda df: df['severity'] - df['surgicalGoodness'] + 3
    )
)

# Save to CSV, excluding prob_duck and surgicalGoodness columns
patients_df[['patient', 'severity', 'doctor_id', 'doctor_name', 'post_surgical_score']].to_csv(
    'patients_data.csv', index=False
)

# Display first few rows
patients_df.head()
```

```{python}
#| label: load-data-python
#| echo: false

import pandas as pd

# Load the observational data
patients_df = pd.read_csv('patients_data.csv')

# Display first few rows to understand the structure
print(f"Number of patients: {len(patients_df)}")
patients_df.head()
```

Let's use data to figure out which surgeon performs better. @fig-plot-outcomes shows the post-surgical symptom score for 100 patients. Doc Duck's average post-surgical symptom score is 3.38 while Doc Dreamy's average is 2.8. Doc Dreamy performs better since lower scores indicate better outcomes. One might ask if the difference in average post-surgical symptom score is statistically significant. A two-sample t-test reveals a statistically significant difference (t = -2.317, p = 0.023). 

### Challenge Task 1: Recover Figure 1 ‚Äî Post-Surgical Outcomes by Patient

**Your task:** Create a scatter plot showing post-surgical symptom scores by patient number, with different markers/colors for each doctor. The figure should include:

- Scatter points for each patient (Doc Dreamy: circles, Doc Duck: triangles)
- Horizontal dashed lines showing the mean for each doctor
- Text annotations showing the mean values with shape symbols (‚óã for Doc Dreamy, ‚ñ≥ for Doc Duck)
- Colorblind-friendly colors (blue for Doc Dreamy, coral/red-orange for Doc Duck)
- Professional styling: clear labels, grid, legend, appropriate font sizes
- X-axis: Patient Number
- Y-axis: Post-Surgical Symptom Score (Lower is Better)
- Title: "Post-Surgical Symptom Score by Patient and Doctor"

```{python}
#| label: fig-plot-outcomes
#| fig-cap: "Post-Surgical Symptom Score (lower is better) - Observed Data"
#| echo: false

import matplotlib.pyplot as plt
import numpy as np

# Separate data by doctor
dreamy_data = patients_df[patients_df['doctor_name'] == 'Doc Dreamy']
duck_data = patients_df[patients_df['doctor_name'] == 'Doc Duck']

# Calculate means
dreamy_mean = dreamy_data['post_surgical_score'].mean()
duck_mean = duck_data['post_surgical_score'].mean()

# Create figure with professional styling
fig, ax = plt.subplots(figsize=(10, 6))

# Plot scatter points
# Doc Dreamy: circles, blue
ax.scatter(dreamy_data['patient'], dreamy_data['post_surgical_score'], 
           marker='o', color='#4E79A7', s=60, alpha=0.7, label='Doc Dreamy', zorder=3)

# Doc Duck: triangles, coral/red-orange
ax.scatter(duck_data['patient'], duck_data['post_surgical_score'], 
           marker='^', color='#E15759', s=60, alpha=0.7, label='Doc Duck', zorder=3)

# Add horizontal dashed lines for means
ax.axhline(y=dreamy_mean, color='#4E79A7', linestyle='--', linewidth=1.5, alpha=0.8, zorder=2)
ax.axhline(y=duck_mean, color='#E15759', linestyle='--', linewidth=1.5, alpha=0.8, zorder=2)

# Add text annotations with shape symbols
ax.text(102, dreamy_mean, f'‚óã {dreamy_mean:.2f}', 
        color='#4E79A7', fontsize=11, va='center', fontweight='bold')
ax.text(102, duck_mean, f'‚ñ≥ {duck_mean:.2f}', 
        color='#E15759', fontsize=11, va='center', fontweight='bold')

# Professional styling
ax.set_xlabel('Patient Number', fontsize=12, fontweight='bold')
ax.set_ylabel('Post-Surgical Symptom Score (Lower is Better)', fontsize=12, fontweight='bold')
ax.set_title('Post-Surgical Symptom Score by Patient and Doctor', fontsize=14, fontweight='bold', pad=15)
ax.grid(True, alpha=0.3, linestyle='-', linewidth=0.5)
ax.legend(loc='upper right', fontsize=11, framealpha=0.9)
ax.set_xlim(-2, 110)

# Adjust tick labels
ax.tick_params(labelsize=10)

plt.tight_layout()
plt.show()

```



## The Hidden Confounder: Patient Severity Explains It All

As readers of @fig-plot-outcomes, the easiest path for our brains is to accept the mental model of surgical outcomes depicted in @fig-example-node.

![DAG Model Explaining Surgical Outcomes](dag-example-node.png){#fig-example-node width=50%}

The obvious conclusion from using the mental model of @fig-example-node and the data shown in @fig-plot-outcomes is that **Doc Dreamy is the superior surgeon because his patients' scores are lower than Doc Duck's patients' scores**.

However, a "common cause" confounder can create an association between $X$ and $Y$ that is not causal in nature. For example, if $X$ is puddles on the road and $Y$ is people with umbrellas, it does not mean that the puddles cause people to have umbrellas. Instead, a common cause for both, namely rain ($Z$), is the sole reason for the observed association. The presence of rain causes both puddles and people to carry umbrellas, creating a spurious correlation between the two.

As Nassim Taleb hints, there may be an alternate explanation. Consider the model shown in @fig-example2-node.  Might there be an unaccounted for common cause that is causing the association between surgeon choice and surgical outcomes?

![DAG Model Explaining Surgical Outcomes](dag-example2-node.png){#fig-example2-node width=50%}

A possible common-cause story would go something like this. Both surgeons have full schedules, with Dr. Dreamy scheduling surgeries 3 weeks in advance and Dr. Duck scheduling surgeries 1 week in advance. As such, patients who are not in a rush, usually those with low severity, are more likely to choose Dr. Dreamy based on his website and picture. However, patients who are in more of a rush, usually those with high severity, are more likely to choose Dr. Duck based on his availability and the fact that he is the only surgeon who can see them immediately.

::: {.callout-warning title="Assumption: Slow Progression of Patient Severity" icon=false}
For simplicity, we assume that patient severity progresses slowly enough that a 2-week delay (i.e., waiting for Dr. Dreamy's availability) has zero effect on surgical outcomes. This delay affects only how quickly patients receive surgical relief, not the eventual outcome itself. While time-to-surgery can be an important factor in other contexts, here we focus solely on whether initial patient severity might create a spurious or biased association between surgeon choice and outcomes.
:::




```{python}
#| label: simulate-data-randomized
#| echo: false
#| message: false
#| warning: false
#| include: false

import pandas as pd
import numpy as np

# Set seed for reproducibility (different from observational data)
np.random.seed(456)

# Create dataframe with 100 patients and severity scores
n_patients_randomized = 100
patients_randomized_df = (
    pd.DataFrame({
        'patient': range(1, n_patients_randomized + 1),
        'severity': np.random.normal(0, 1, n_patients_randomized)
    })
    .assign(
        # Randomly assign doctors: 50/50 chance, independent of severity
        # This breaks the confounding relationship
        doctor_id=lambda df: np.random.choice([0, 1], size=n_patients_randomized),
        # Assign doctor names based on id
        doctor_name=lambda df: np.where(df['doctor_id'] == 1, 'Doc Dreamy', 'Doc Duck'),
        # Assign surgical goodness:
        # Doc Duck: Normal(0.5, 1), Doc Dreamy: Normal(-0.4, 1)
        # Same true effect as before - Doc Duck is better
        surgicalGoodness=lambda df: np.where(
            df['doctor_name'] == 'Doc Duck',
            np.random.normal(0.5, 1, n_patients_randomized),
            np.random.normal(-0.4, 1, n_patients_randomized)
        ),
        # Calculate post-surgical severity: initial severity - surgical goodness + 3
        post_surgical_score=lambda df: df['severity'] - df['surgicalGoodness'] + 3
    )
)

# Save to CSV, excluding surgicalGoodness column
patients_randomized_df[['patient', 'severity', 'doctor_id', 'doctor_name', 'post_surgical_score']].to_csv(
    'patients_data_randomized.csv', index=False
)

# Display first few rows
patients_randomized_df.head()
```

```{python}
#| label: load-data-randomized-python
#| echo: false

import pandas as pd

# Load the randomized data
patients_randomized_df = pd.read_csv('patients_data_randomized.csv')

# Display first few rows
print(f"Number of randomized patients: {len(patients_randomized_df)}")
patients_randomized_df.head()
```


### Challenge Task 2: Recover Figure 2 ‚Äî Randomized Assignment Outcomes

**Your task:** Create a scatter plot similar to Figure 1, but for the randomized data. The figure should show how randomization breaks the confounding relationship. Include:

- Same styling as Figure 1 (markers, colors, mean lines, annotations)
- Title should indicate this is randomized assignment
- Same colorblind-friendly color scheme
- Professional styling consistent with Figure 1

```{python}
#| label: fig-plot-outcomes-randomized
#| fig-cap: "Post-Surgical Symptom Score (lower is better) for randomized patients."
#| echo: false

import matplotlib.pyplot as plt
import numpy as np

# Separate randomized data by doctor
dreamy_data_rand = patients_randomized_df[patients_randomized_df['doctor_name'] == 'Doc Dreamy']
duck_data_rand = patients_randomized_df[patients_randomized_df['doctor_name'] == 'Doc Duck']

# Calculate means
dreamy_mean_rand = dreamy_data_rand['post_surgical_score'].mean()
duck_mean_rand = duck_data_rand['post_surgical_score'].mean()

# Create figure with professional styling
fig, ax = plt.subplots(figsize=(10, 6))

# Plot scatter points
# Doc Dreamy: circles, blue
ax.scatter(dreamy_data_rand['patient'], dreamy_data_rand['post_surgical_score'], 
           marker='o', color='#4E79A7', s=60, alpha=0.7, label='Doc Dreamy', zorder=3)

# Doc Duck: triangles, coral/red-orange
ax.scatter(duck_data_rand['patient'], duck_data_rand['post_surgical_score'], 
           marker='^', color='#E15759', s=60, alpha=0.7, label='Doc Duck', zorder=3)

# Add horizontal dashed lines for means
ax.axhline(y=dreamy_mean_rand, color='#4E79A7', linestyle='--', linewidth=1.5, alpha=0.8, zorder=2)
ax.axhline(y=duck_mean_rand, color='#E15759', linestyle='--', linewidth=1.5, alpha=0.8, zorder=2)

# Add text annotations with shape symbols
ax.text(102, dreamy_mean_rand, f'‚óã {dreamy_mean_rand:.2f}', 
        color='#4E79A7', fontsize=11, va='center', fontweight='bold')
ax.text(102, duck_mean_rand, f'‚ñ≥ {duck_mean_rand:.2f}', 
        color='#E15759', fontsize=11, va='center', fontweight='bold')

# Professional styling
ax.set_xlabel('Patient Number', fontsize=12, fontweight='bold')
ax.set_ylabel('Post-Surgical Symptom Score (Lower is Better)', fontsize=12, fontweight='bold')
ax.set_title('Post-Surgical Symptom Score (Randomized Assignment)', fontsize=14, fontweight='bold', pad=15)
ax.grid(True, alpha=0.3, linestyle='-', linewidth=0.5)
ax.legend(loc='upper right', fontsize=11, framealpha=0.9)
ax.set_xlim(-2, 110)

# Adjust tick labels
ax.tick_params(labelsize=10)

plt.tight_layout()
plt.show()

```
 

### Challenge Task 3: Recover Figure 3 ‚Äî Outcomes by Patient Severity (Stratification)

**Your task:** Create a scatter plot showing post-surgical outcomes as a function of initial patient severity. This figure demonstrates the power of stratification. Include:

- X-axis: Initial Patient Severity
- Y-axis: Post-Surgical Symptom Score (Lower is Better)
- Scatter points colored/marked by doctor (same scheme as previous figures)
- Mean horizontal lines for each doctor
- A rectangular overlay (shaded region) highlighting severity between -1 and 1
- Text annotations for means positioned appropriately
- Title: "Post-Surgical Symptom Score by Patient Severity"
- This figure should reveal the confounding by showing how severity affects both surgeon assignment and outcomes

```{python}
#| label: fig-plot-outcomes-severity
#| fig-cap: "Post-Surgical Symptom Score (lower is better) by Patient and Severity"
#| echo: false

import matplotlib.pyplot as plt
import numpy as np

# Separate data by doctor
dreamy_data = patients_df[patients_df['doctor_name'] == 'Doc Dreamy']
duck_data = patients_df[patients_df['doctor_name'] == 'Doc Duck']

# Calculate means
dreamy_mean = dreamy_data['post_surgical_score'].mean()
duck_mean = duck_data['post_surgical_score'].mean()

# Create figure with professional styling
fig, ax = plt.subplots(figsize=(10, 6))

# Add shaded region highlighting severity between -1 and 1 (behind everything)
ax.axvspan(-1, 1, alpha=0.15, color='gray', zorder=0)

# Plot scatter points
# Doc Dreamy: circles, blue
ax.scatter(dreamy_data['severity'], dreamy_data['post_surgical_score'], 
           marker='o', color='#4E79A7', s=60, alpha=0.7, label='Doc Dreamy', zorder=3)

# Doc Duck: triangles, coral/red-orange
ax.scatter(duck_data['severity'], duck_data['post_surgical_score'], 
           marker='^', color='#E15759', s=60, alpha=0.7, label='Doc Duck', zorder=3)

# Add horizontal dashed lines for means
ax.axhline(y=dreamy_mean, color='#4E79A7', linestyle='--', linewidth=1.5, alpha=0.8, zorder=2)
ax.axhline(y=duck_mean, color='#E15759', linestyle='--', linewidth=1.5, alpha=0.8, zorder=2)

# Set x-axis limits to accommodate annotations
x_min = min(patients_df['severity'].min(), -3.0)
x_max = max(patients_df['severity'].max(), 3.0)

# Professional styling
ax.set_xlabel('Initial Patient Severity', fontsize=12, fontweight='bold')
ax.set_ylabel('Post-Surgical Symptom Score (Lower is Better)', fontsize=12, fontweight='bold')
ax.set_title('Post-Surgical Symptom Score by Patient Severity', fontsize=14, fontweight='bold', pad=15)
ax.grid(True, alpha=0.3, linestyle='-', linewidth=0.5)
ax.legend(loc='upper right', fontsize=11, framealpha=0.9)
ax.set_xlim(left=x_min, right=x_max + 0.8)

# Add text annotations with shape symbols positioned on the right side
ax.text(x_max + 0.2, dreamy_mean, f'‚óã {dreamy_mean:.2f}', 
        color='#4E79A7', fontsize=11, va='center', fontweight='bold')
ax.text(x_max + 0.2, duck_mean, f'‚ñ≥ {duck_mean:.2f}', 
        color='#E15759', fontsize=11, va='center', fontweight='bold')

# Adjust tick labels
ax.tick_params(labelsize=10)

plt.tight_layout()
plt.show()

```



## Submission Checklist ‚úÖ

**For 85% (Base Grade):**

- [ ] Fork the `confounderChallenge` repository
- [ ] Clone locally and open in Cursor
- [ ] Recover all three figures (Tasks 1-3)
- [ ] Ensure figures match the narrative descriptions
- [ ] Render to HTML (`quarto render` or Render button)
- [ ] Verify all figures render correctly
- [ ] Push HTML to your repo and enable GitHub Pages
- [ ] Share your site: `https://[your-username].github.io/confounderChallenge/`

**For Final 15% (Bonus - 100% Total):**

- [ ] Remove all challenge-related comments from code (no "TODO", "Challenge Task", "Recover Figure")
- [ ] Transform document title/subtitle to "Using Randomization & Stratification to Overcome A Common Cause Confounder"
- [ ] Remove challenge framing sections (challenge callout, submission checklist, tips)
- [ ] Polish the document to read like a complete, professional report
- [ ] Ensure the narrative flows naturally without challenge references

## Tips

- Read the narrative carefully‚Äîit contains hints about what each figure should show
- Use the statistical results mentioned in the text to verify your figures are correct
- Keep styling consistent across all three figures
- Test with both R and Python code chunks if you want to show versatility
- Set random seeds if you're doing any additional analysis for reproducibility
